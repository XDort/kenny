#### 1、依赖注入（DI）

可以使用服务定位器注入和.net框架提供的依赖注入

服务定位器需要手动注册和获取服务，使用IServiceProvider

.net框架的DI也需要手动注册，默认使用构造器注入

注册先创建ServiceCollection 容器，然后调用BuildServiceProvider创建serviceProvider调用方法获取对象，对象中要使用构造器注入

（1）对象生命周期：

Transient 多例、

Scoped 配合using创建scope，在同一scope中获取的对象是单例的、

Singleton 单例

不要在长生命周期对象引用短生命周期对象，会报错



（2）引入autofac依赖注入框架取代ServiceCollection

先引入autofac和autofac.Extension.DependencyInjection的两个nuget包

然后中libraries中的Core solution下创建module类，继承Autofac包中的Module类

⚠️不要继承到.net的同名包

在libraries中创建autofac的Module继承类，重写load方法注册自己写的Service

```
public class PractiseForKennyModule : Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterType<HelloWorldServiceImpl>().As<IHelloWorldService>().SingleInstance();
        base.Load(builder);
    }
}
```

在startup.cs中注册autofac模块

```
public void ConfigureContainer(ContainerBuilder builder)
{
    builder.RegisterModule(new PractiseForKennyModule());
}
```

在program.cs中的CreateHostBuilder配置开启autofac的依赖注入

```
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .UseServiceProviderFactory(new AutofacServiceProviderFactory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
            
        });
```



### autofac创建的实例在三种模式下的释放时机

autofac管理的对象，如果实现了dispose方法，且未主动调用过，则在GC时会尝试调用

autofac的InstancePerLifetimeScope()模式下，在请求结束后GC会尝试释放实例，调用dispose方法

InstancePerDependency()模式下，对象不再被引用后，由GC控制释放实例

SingleInstance()模式，则会在容器本身被释放时释放对象。

⚠️.net core 父容器释放不影响子容器使用

但autofac中，从一个`ILifetimeScope`容器中获取服务时，它会检查当前容器以及所有的父、祖父等容器是否有效，也就是有没有释放，如果已释放，那么子容器就不可以使用了
