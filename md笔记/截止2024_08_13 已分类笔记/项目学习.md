IHttpHeaderInfoProvider 获取请求头信息的provider



基于策略的授权策略

```
services.AddAuthorization(options =>
{
    options.AddPolicy("MyPolicy", x =>
    {
        x.RequireAuthenticatedUser();
        x.AddAuthenticationSchemes("MySchema");
    });
    
    var defaultAuthorizationPolicyBuilder = new AuthorizationPolicyBuilder(
        "xxxx", 
        "Wechat"
    );
    defaultAuthorizationPolicyBuilder = defaultAuthorizationPolicyBuilder.RequireAuthenticatedUser();
    options.DefaultPolicy = defaultAuthorizationPolicyBuilder.Build();
});
```



默认要求所有用户进行身份验证，但具有 `[AllowAnonymous]` 或 `[Authorize(PolicyName="MyPolicy")]` 的 Razor Pages、控制器或

操作方法使用默认或者指定的授权属性



autofac的module类的构造函数中的参数，是在starup类中手动new出来的，因为此时容器还没注册好，其中部分读取自配置文件，可以去startup类查找。这些参数用于配置module类。



hangfire 自定义的任务调度类XxxJobRunner会在run方法里使用_lifetimeScope.BeginLifetimeScope()新开一个scope来获取具体的IRecurringJob的实现类实例，再用该实例job Execute方法执行具体逻辑，通常是由mediator发送消息



目前项目上使用工厂模式和lambda表达式创建后台任务、延时任务。区分在starup注册添加的定时任务

如果有传时区ID参数，保存的时间要按当前时间转换成对应时区的时间来存储，类型是 DateTimeOffset （包含了时区和时间信息）



Newtonsoft.Json JSON序列化和反序列化工具

string json = JsonConvert.SerializeObject(person);

Person person = JsonConvert.DeserializeObject\<Person>(json);



到期时间以当前时间（对应时区的时间）加上续订时间-1s确定，精确到秒



个人的考核项目，发现之前要求使用的[StringLength]特性不生效，搜索发现默认情况下，验证是在模型绑定过程中进行的，或者在手动调用 `Validator.TryValidateObject` 时进行的



查看项目上，貌似是在DbContext的OnBeforeSaveAsync自定义方法中编写了使用实现了IEntityFluentValidator的自定义Validator进行校验的逻辑

但与StringLength这个efcore包的特性无关



#### 项目 定时任务变更订单状态的大体流程梳理

ScheduleMarkOrdersAsReadyJob：

 定时任务类 通过_mediator.SendAsync定期发送command



MarkOrdersAsCompletedCommandHandler ：

通过调用_scheduleOrderStatusUpdateService.MarkOrdersAsReady查询所有应该变更状态的订单，并封装成一个ordersAutoReadyEvent返回

遍历ordersAutoReadyEvent中应修改状态的订单，调用_orderService.UpdateOrderStatusAsync进行修改，返回statusUpdatedEvent

并且在循环体内捕获异常，手动开启事务回滚，每次循环通过context.PublishAsync发布statusUpdatedEvent事件



OrderCompletedEventHandler 执行状态修改为完成后的逻辑



OnMessageSentEventHandler 接受OrderStatusUpdatedNotificationEvent事件，通过_signalRService.SendSignalRMessage给商家发送订单状态变更的消息



NotificationPublisherOnOrderStatusChanged 打印机服务、发送通知给用户相关



#### 结合需求文档对应部分和数据库，学习付费会员后台管理接口"operate"，学习取消续订和关闭会员的流程和功能实现

取消续订和关闭会员操作依赖于列表项，先查看后台会员列表相关接口

#### 列表接口"list":

##### 校验管理员

先调用IUserService.cs的CheckAdminForCurrentLoggedInUser方法：

从_httpContextAccessor获取当前登陆用户实体，再根据用户id连接管理员表查询实体，验证管理员身份

能返回管理员对应user实体则不抛出异常

##### 拼接条件并查询会员实体集合

先根据前端传递的merchId查询，前端未传递则使用注入的默认商家id配置



这样拼接条件可以满足同一个字段实现精确查询和模糊查询两种方式

```c#
if (!string.IsNullOrEmpty(keyword))
    query = Guid.TryParse(keyword, out var userId)
        ? query.Where(x => x.UserId == userId)
        : query.Where(x => x.UserDisplayName.Contains(keyword));
```



if (xxxXxx.HasValue)

拼接前端传递的筛选参数



执行查询返回分页后的结果和纪录条数



#### 对会员实体集合进行增强

从_httpHeaderInfoProvider中通过请求头拿到当前商家id、languageCode、sourceSystemType



根据sourceSystemType拿到当前商家id或会员相关商家id

拿到会员实体集合中的userId

根据userIds和商家id获取会员的购买记录的集合

从会员购买记录集合中获取订单ids集合

根据orderIds获取一个Dictionary<Guid, long>集合，value为订单id对应seed

遍历会员购买记录集合，通过字典orderSeedDic.TryGetValue(x.OrderId, out var seed);获取到每个购买记录对应的订单seed

并向会员购买记录中设置以下两个NotMapped字段

```c#
x.Seed = seed;
x.PlanName = PremiumMemberPlanUtil.GetPlanName(languageCode, x.PremiumMemberFeeType);
```

PlanName为会员购买记录付费类型对应的翻译，通过languageCode和PremiumMemberFeeType确定

遍历会员集合，设置会员对应的购买记录

最后map对应dto返回list



会员后台查询list后，根据会员状态，发送请求到operate接口来批量取消会员

前端传递PremiumMemberIds和OperationType

Service层实现：

首先同样调用CheckAdminForCurrentLoggedInUser检查用户有无管理员权限

通过PremiumMemberIds查询出会员实体集合

遍历会员实体集合，如果包含状态为已过期的会员则抛出异常，批量操作失败

switch根据传递的OperationType决定取消会员或取消续订



取消会员：

批量更新会员集合的到期日期为现在，状态为已过期

筛选出连续包月的会员取消自动续费：

批量更新会员实体的NextRenewalDate为null和PremiumMemberFeeType从连续包月修改为月费

遍历每个会员实体生成取消续费的记录并插入数据库

根据用户id查询相关的会员定时任务记录

_yamimealBackgroundJobClientProvider.DeleteJob(premiumMemberJobRecord.JobId) 删除相关的任务



取消续费：

同上