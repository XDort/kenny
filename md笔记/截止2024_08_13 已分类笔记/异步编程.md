#### 1、异步编程

（1）异步方法：用async关键字修饰，返回值一般是Task\<T> T是返回值类型

（2）没有返回值，也要加上无泛型Task返回值

（3）调用异步方法时，在方法前加上 await，这样拿到的返回值就直接是泛型指定的类型

（4）使用了await的方法，本身也必须是异步方法

（5）`IDisposable` 接口

如果一个类需要管理非内存资源（如文件、数据库连接等），应该实现 `IDisposable` 接口，并在类中实现 `Dispose` 方法。`IDisposable` 接口中只定义了一个方法：void Dispose();

实现 `Dispose` 方法的类必须在方法内释放非内存资源

`using` 关键字必须用在实现了 `IDisposable` 接口的类型上，以确保资源正确释放

也可以手动去释放资源

（6）await

c#中的异步操作和任务默认使用.NET Core 提供的线程池执行

`await` 修饰的方法不会直接导致新线程的创建。线程回到线程池，等await方法执行完毕，再利用现有的线程池中的线程来继续执行

不会阻塞当前线程，但是可能会导致前后执行的线程不同

方法执行短时优化了，不会切换线程

有些时候返回值是task，但不需要经过复杂处理也不需要等待时，可以不使用await和async，使用await只是为了把异步操作的结果值取出



#### 2、Task.delay() 

异步方法中用Task.delay() 不用Thread.sleep()会阻塞当前线程



#### 3、CancellationToken

CancellationToken用来取消操作，防止用户取消后服务器资源继续占用

自己去写的话，要考虑执行到判断超时的语句是同步的。

使用的方法有CancellationToken重载的话，可以看看取消的逻辑

有的可能封装好，可以在超时时直接取消操作



#### 4、.ConfigureAwait(false);

`.ConfigureAwait(false)` 被添加在异步方法后，异步方法执行后不会尝试恢复到调用线程的上下文环境中。这对于数据库查询等大量 I/O 操作来说，能够减少不必要的线程切换开销，提升系统的整体性能。

在控制台应用程序或后台服务中，没有特定的同步上下文，所以任务继续在线程池的线程上执行。

如果明确希望任务在线程池线程上执行，调用ConfigureAwait(false)可以避免捕获同步上下文，提高性能和减少死锁风险。



#### 任务异步模型

https://learn.microsoft.com/en-gb/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model



### 理解async和await

#### 系统提供的异步 I/O API

.net中大多数内置的异步方法是依赖于底层的异步 I/O 操作或异步编程模型来避免阻塞线程

在异步 I/O 操作中，当应用程序发起 I/O 请求时，当前线程不会被阻塞。它会继续执行其他任务或空闲，直到 I/O 操作完成。这个线程实际上是释放了进行其他工作，或将其用于其他任务。

操作系统通常使用事件对象、信号、回调函数等机制来通知应用程序 I/O 操作的完成。异步方法的恢复通常会在线程池线程上继续执行。



**1.说明**

　async和await是一种异步编程模型，用于简化代码，达到“**同步的方式写异步的代码**”,编译器会将async和await修饰的代码编译成状态机,它们**本身是不开启线程的**。

**2.深层理解**

(1).async和await只是一个状态机，执行流程如下：

await调用自己封装的异步方法时，还不会释放当前线程，只有执行到异步方法中的【异步操作】时且调用了await且还未完成才会释放

 await时释放当前线程(当前线程回到线程池,可供别人调用)→进入状态机等待【异步操作】完成→退出状态机,从线程池中返回一个新的线程执行await下面的代码

**注：这里新的线程，有几率是原线程；状态机本身不会产生新的线程。**

   CLR内部有个优化，当要 等待【异步操作】完成的时候（执行到await），如果发现已经执行结束了，那就没必要切换线程了，剩下的代码在之前的线程上继续执行了。

(2).**【异步操作】**分为两种

　A.CPU-Bound(计算密集型)：比如 Task.Run ,这时释放当前线程，异步操作会在一个新的线程中执行。

　B.IO-Bound(IO密集型)：比如一些非阻止Api, 像EF的SaveChangesAsync、写文件的WriteLineAsync，这时释放当前线程，异步操作不占用线程。

**那么IO操作是靠什么执行的呢？**

　是以 操作系统的异步IO API为基础的，因此不需要新建一个线程或使用线程池里面的线程来执行具体工作。操作系统直接操作CPU线程。



总结：await调用异步方法时，会先执行异步方法中的同步代码部分，直到遇到await调用并需要等待，比如 Task.Run、网络请求、异步IO操作，才会释放当前线程的控制权。任务完成继续执行后续代码，此时继续执行后续代码的线程是从线程池中调度的。

如果调用await时，异步方法已完成（不需要等待）则不会切换线程。

比如HttpClient.GetStringAsync，一开始进入方法执行时还不会释放线程，实际的线程释放发生在网络 I/O 操作期间。网络请求被发起后，线程会被释放，允许其他任务在此线程上执行。线程释放是由异步 I/O 操作实现的，具体由操作系统或底层库来管理。

又比如await 嵌套调用时，调用最后一个await时并开始等待时才会去释放当前线程

